<!doctype html>
<html lang="ru" data-theme="dark">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="color-scheme" content="dark" />
  <title>Тикет — nevrqx</title>
  <link rel="preconnect" href="https://cdn.jsdelivr.net" />
  <link rel="stylesheet" href="./style.css" />
  <style>
    body { padding: 24px; }
    .ticket-page { width: 1280px; max-width: calc(100vw - 48px); margin: 0 auto; }
    .ticket-header { margin-bottom: 16px; }
    .ticket-header h1 { margin: 0 0 6px 0; }
    .ticket-meta { color: var(--text-muted); font-size: 14px; }
    .reply-bar { position: sticky; bottom: 0; background: rgba(0,0,0,0.2); backdrop-filter: blur(8px); border-top: 1px solid var(--border); padding: 12px; border-radius: 12px; }
    .admin-badge { margin-left:6px; display:inline-block; background: var(--primary, #6d28d9); color:#fff; width:16px; height:16px; line-height:16px; text-align:center; border-radius:50%; font-size:12px; font-weight:700; }
  </style>
</head>
<body>
  <main class="ticket-page">
    <div class="ticket-header">
      <div class="row between align-center" style="gap:12px; margin-bottom:8px;">
        <button id="backBtn" class="btn ghost" type="button">← Назад</button>
      </div>
      <h1 id="tTitle">Тикет</h1>
      <div id="tMeta" class="ticket-meta">—</div>
    </div>
    <section id="tThread" class="comment-tree card" style="padding: 16px;"></section>
    <div id="tEmpty" class="muted" hidden>Нет сообщений</div>
    <div id="tReply" class="reply-bar" hidden>
      <div class="row gap-sm">
        <input id="replyInput" type="text" placeholder="Ваш ответ…" style="flex:1" />
        <button id="replyBtn" class="btn primary">Ответить</button>
      </div>
    </div>
  </main>

  <!-- Supabase JS -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script>
    // Дублируем ключи как в index.html (можно заменить на ENV при деплое)
    window.SUPABASE_URL = 'https://ubyveomgijyjudfwrtdw.supabase.co';
    window.SUPABASE_ANON_KEY = 'sb_publishable_Y-S2Aslm0eISSlsXB4Um0A_M0Mip6IE';
    // Важно: email администратора, как и в index.html, для быстрого распознавания роли
    window.ADMIN_EMAIL = 'nevrqx@gmail.com';
  </script>
  <script src="./config.js"></script>
  <script>
    const qs = new URLSearchParams(location.search);
    const ticketId = qs.get('id');
    const { url, key } = window.getSupabaseConfig();
    // Клиент с авторизацией (если вы вошли в админку в этом же браузере)
    const supaAuth = window.supabase.createClient(url, key, {
      auth: {
        persistSession: true,
        autoRefreshToken: true,
        detectSessionInUrl: true,
      }
    });
    // Отдельный «анонимный» клиент без хранения сессии — чтобы пользовательские ответы не шли как админ
    const supa = window.supabase.createClient(url, key, { auth: { persistSession: false } });
    let currentUser = null;
    let isAdmin = false;
    // Фиксированное отображаемое имя администратора
    let adminDisplayName = 'nevrqx admin';
    let ticketUserName = null; // ник, закреплённый за IP (как в комментариях)
    let currentDisplayName = null; // ник из профиля пользователя

    function escapeHtml(s) {
      return (s || '').replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c]));
    }
    function fmtDate(s) { try { return new Date(s).toLocaleString('ru-RU'); } catch { return s || ''; } }
    function shortHash(id) { try { return String(id).split('-')[0]; } catch { return String(id).slice(0,8); } }
    function pad3(n){ return String(n).padStart(3,'0'); }

    const adminMode = (qs.get('admin') === '1'); // если открыто из админки — принудительный админ-контекст
    async function detectAdmin() {
      try {
        // Ignore any localStorage admin hints on this public page
        isAdmin = false;
        // На некоторых окружениях getUser() возвращает null, пока не дернули getSession()
        const { data: sess } = await supaAuth.auth.getSession();
        currentUser = sess?.session?.user || null;
        if (!currentUser) {
          const { data: auth } = await supaAuth.auth.getUser();
          currentUser = auth?.user || null;
        }
        if (!currentUser) return;
        // Fetch profile once to get role and display_name
        let role = null; let display_name = null;
        let { data: prof, error: e1 } = await supaAuth
          .from('profiles')
          .select('role, display_name, email')
          .eq('id', currentUser.id)
          .maybeSingle();
        if (!e1 && prof) { role = prof.role; display_name = prof.display_name; }
        // Do NOT auto-elevate by email on this page. Admin only by role.
        if (!role) {
          // fallback to user_id in case schema differs
          const { data: prof2 } = await supaAuth
            .from('profiles')
            .select('role, display_name')
            .eq('user_id', currentUser.id)
            .maybeSingle();
          role = prof2?.role || role;
          display_name = display_name || prof2?.display_name || null;
        }
        // Считаем пользователя админом, если:
        // 1) роль профиля = admin, ИЛИ
        // 2) email совпадает с ADMIN_EMAIL, ИЛИ
        // 3) есть флаг в localStorage, выставленный админкой
        const email = (currentUser?.email || '').trim().toLowerCase();
        const adminEmail = (window.ADMIN_EMAIL || '').trim().toLowerCase();
        let lsAdmin = false;
        try { lsAdmin = localStorage.getItem('nvx_is_admin') === '1'; } catch(_) {}
        isAdmin = (role === 'admin') || (!!adminEmail && email === adminEmail) || lsAdmin;
        // Если пришли из админки по явной ссылке — повысим контекст независимо от чтения профиля
        if (adminMode) isAdmin = true;
        currentDisplayName = display_name || currentUser.user_metadata?.name || (currentUser.email ? currentUser.email.split('@')[0] : null);
        // Admin name (from profile/name/email)
        adminDisplayName = currentDisplayName || 'Админ';
      } catch (_) { /* noop */ }
    }

    async function loadTicket() {
      if (!ticketId) { document.getElementById('tTitle').textContent = 'Тикет не указан'; return; }
      const { data: t, error } = await supa.from('support_tickets').select('*').eq('id', ticketId).single();
      if (error) { console.warn('ticket load error', error); document.getElementById('tTitle').textContent = 'Ошибка загрузки'; return; }
      let displayNum = null;
      try {
        // Берём все тикеты пользователя и считаем индекс текущего (как в профиле — новые сверху)
        const { data: list } = await supa
          .from('support_tickets')
          .select('id')
          .eq('user_ip', t.user_ip)
          .order('updated_at', { ascending: false })
          .limit(200);
        if (Array.isArray(list) && list.length) {
          const idx = list.findIndex(x => String(x.id) === String(t.id));
          if (idx >= 0) displayNum = pad3(idx + 1);
        }
      } catch(e) { /* fallback ниже */ }

      const titleText = displayNum ? `Тикет №${displayNum} — ${t.subject || ''}` : `Тикет #${shortHash(t.id)} — ${t.subject || ''}`;
      document.getElementById('tTitle').textContent = titleText;
      document.getElementById('tMeta').textContent = `${t.status === 'open' ? 'Открыт' : 'Закрыт'} · обновлён ${fmtDate(t.updated_at || t.created_at)}`;

      // Попробуем подтянуть ник по IP
      ticketUserName = null;
      try {
        if (t.user_ip) {
          const { data: ipn } = await supa.from('ip_names').select('author_name').eq('ip', t.user_ip).maybeSingle();
          ticketUserName = ipn?.author_name || null;
        }
      } catch (_) {}

      const { data: msgs, error: e2 } = await supa
        .from('support_messages')
        .select('*')
        .eq('ticket_id', t.id)
        .order('created_at', { ascending: true });
      if (e2) console.warn('msgs load', e2);
      renderThread(t, msgs || []);
    }

    function renderThread(ticket, msgs) {
      const wrap = document.getElementById('tThread');
      wrap.innerHTML = '';
      if (!msgs.length) document.getElementById('tEmpty').hidden = false; else document.getElementById('tEmpty').hidden = true;
      msgs.forEach(m => {
        const admin = m.author_role === 'admin';
        const displayName = admin ? adminDisplayName : (m.author_name || ticketUserName || ticket.creator_name || 'посетитель');
        const badge = admin ? '<span class="admin-badge" title="Админ">!</span>' : '';
        const avatar = admin ? 'A' : 'G';
        const div = document.createElement('div');
        div.className = `comment ${admin ? 'comment-admin' : ''}`;
        div.innerHTML = `
          <div class="comment-header">
            <div class="comment-author">
              <div class="avatar">${avatar}</div>
              <span class="comment-author-name">${escapeHtml(displayName)}</span>${badge}
            </div>
            <div class="comment-meta small text-muted">${fmtDate(m.created_at)}</div>
          </div>
          <div class="comment-body">${escapeHtml(m.body || '')}</div>
        `;
        wrap.appendChild(div);
      });

      // reply
      const reply = document.getElementById('tReply');
      if (ticket.status === 'open') {
        reply.hidden = false;
        document.getElementById('replyBtn').onclick = async () => {
          const val = document.getElementById('replyInput').value.trim();
          if (!val) return;
          document.getElementById('replyBtn').disabled = true;
          const payload = {
            ticket_id: ticket.id,
            body: val,
            // Если страница открыта из админки или реально авторизован админ — пишем как админ
            author_role: (isAdmin || adminMode) ? 'admin' : 'user',
            // Админ всегда отвечает фиксированным ником (не личный профиль)
            author_name: (isAdmin || adminMode)
              ? adminDisplayName
              : (currentDisplayName || ticketUserName || ticket.creator_name || 'посетитель')
          };
          // Админ — пишем через авторизованный клиент, пользователь — строго через анонимный
          const clientToUse = (isAdmin || adminMode) ? supaAuth : supa;
          const { error } = await clientToUse.from('support_messages').insert(payload);
          document.getElementById('replyBtn').disabled = false;
          if (!error) {
            document.getElementById('replyInput').value = '';
            await loadTicket();
          } else {
            console.error('[ticket] send error:', error);
            alert('Ошибка отправки: ' + (error?.message || 'неизвестная ошибка'));
          }
        };
      } else {
        reply.hidden = true;
      }
    }

    // back button
    document.getElementById('backBtn').onclick = () => {
      if (history.length > 1) history.back();
      else window.location.href = './index.html#/profile';
    };

    // Ensure we know admin status before enabling replies
    detectAdmin().then(loadTicket);
  </script>
</body>
</html>
